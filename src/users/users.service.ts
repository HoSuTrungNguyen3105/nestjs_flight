import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import * as bcrypt from 'bcrypt';
import { PrismaService } from 'src/prisma.service';
import { Department, Position, Prisma, Role } from 'generated/prisma';
import { BaseResponseDto } from 'src/baseResponse/response.dto';
import { generatePassword } from './hooks/randompw';
import { UserResponseDto } from './dto/info-user-dto';
import { formatUserResponse, toEpochDecimal } from 'src/common/helpers/hook';
import { Decimal } from 'generated/prisma/runtime/library';
import { MailService } from 'src/common/nodemailer/nodemailer.service';
import { nowDecimal } from 'src/common/helpers/format';
import { UpdateUserInfoDto } from './dto/update-user.dto';
import { UpdateUserFromAdminDto } from './dto/update-user-from-admin.dto';
import { v2 as cloudinary } from 'cloudinary';
import { CreateLeaveRequestDto } from './dto/leave-request.dto';
import { SearchUserDto } from './dto/search-user.dto';
import { PaginatedUserResponse } from './dto/user-response.dto';

@Injectable()
export class UsersService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly mailService: MailService,
  ) {}

  async randomPw() {
    const password = await generatePassword(true);
    return {
      resultCode: '00',
      resultMessage: 'L·∫•y temp password th√†nh c√¥ng!',
      data: password,
    };
  }

  async getAllUsers(): Promise<BaseResponseDto<Partial<UserResponseDto>>> {
    const users = await this.prisma.user.findMany({
      select: {
        id: true,
        email: true,
        name: true,
        rank: true,
        role: true,
        authType: true,
        userAlias: true,
        accountLockYn: true,
        mfaEnabledYn: true,
        attendance: true,
        baseSalary: true,
        department: true,
        position: true,
        hireDate: true,
        status: true,
      },
    });

    return {
      resultCode: '00',
      resultMessage: 'L·∫•y danh s√°ch ng∆∞·ªùi d√πng th√†nh c√¥ng!',
      list: users,
    };
  }

  async promoteRank(userId: number) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });
    if (!user) throw new Error('User not found');

    const now = Date.now();
    const hireDate = user.hireDate ? Number(user.hireDate) : Date.now();
    const yearsWorked = (now - hireDate) / (1000 * 60 * 60 * 24 * 365);

    let newRank = user.rank || 'NONE';

    if (user.position === 'STAFF' && yearsWorked >= 2) newRank = 'MID';
    else if (user.position === 'SENIOR' && yearsWorked >= 4) newRank = 'LEAD';
    else if (user.position === 'MANAGER' && yearsWorked >= 5)
      newRank = 'PRINCIPAL';
    if (newRank !== user.rank) {
      return await this.prisma.user.update({
        where: { id: userId },
        data: { rank: newRank || 'NONE' },
      });
    }
    return {
      resultCode: '00',
      resultMessage: 'Update rank ng∆∞·ªùi d√πng th√†nh c√¥ng!',
    };
  }

  async getUserById(
    id: number,
  ): Promise<BaseResponseDto<Partial<UserResponseDto>>> {
    const user = await this.prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        email: true,
        name: true,
        pictureUrl: true,
        rank: true,
        role: true,
        authType: true,
        isEmailVerified: true,
        userAlias: true,
        accountLockYn: true,
      },
    });

    return {
      resultCode: '00',
      resultMessage: 'L·∫•y danh s√°ch ng∆∞·ªùi d√πng th√†nh c√¥ng!',
      data: user,
    };
  }

  async getUserInfo(
    id: number,
  ): Promise<BaseResponseDto<Partial<UserResponseDto>>> {
    const user = await this.prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        email: true,
        name: true,
        pictureUrl: true,
        rank: true,
        role: true,
        authType: true,
        isEmailVerified: true,
        mfaEnabledYn: true,
        userAlias: true,
        accountLockYn: true,
        loginFailCnt: true,
        lastLoginDate: true,
        hireDate: true,
        status: true,
        baseSalary: true,
        passport: true,
        attendance: true,
        position: true,
        phone: true,
        createdAt: true,
        updatedAt: true,
        sessions: {
          select: {
            id: true,
            createdAt: true,
            userId: true,
          },
        },
      },
    });

    if (!user) {
      return {
        resultCode: '01',
        resultMessage: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng',
      };
    }

    const safeUser: UserResponseDto = {
      ...user,
      createdAt: (user.createdAt as Decimal).toNumber(),
      updatedAt: (user.updatedAt as Decimal).toNumber(),
      lastLoginDate: user.lastLoginDate
        ? (user.lastLoginDate as Decimal).toNumber()
        : undefined,
    };

    return {
      resultCode: '00',
      resultMessage: 'L·∫•y th√¥ng tin ng∆∞·ªùi d√πng th√†nh c√¥ng!',
      data: safeUser,
    };
  }

  async requestTransfer(data: {
    userId: number;
    fromUserId: number;
    toUserId: number;
  }) {
    return this.prisma.transferAdmin.create({
      data: {
        ...data,
        requestedAt: nowDecimal(),
        status: 'PENDING',
      },
    });
  }

  async approveTransfer(userId: number) {
    try {
      const transfer = await this.prisma.transferAdmin.findUnique({
        where: { userId },
        include: { user: true },
      });

      if (!transfer) {
        return {
          resultCode: '01',
          resultMessage: `Kh√¥ng t√¨m th·∫•y Transfer v·ªõi userId = ${userId}`,
        };
      }

      const [updatedTransfer, updatedUser] = await this.prisma.$transaction([
        this.prisma.transferAdmin.update({
          where: { userId },
          data: {
            status: 'APPROVED',
            approvedAt: new Date().getTime().toString(),
          },
        }),
        this.prisma.user.update({
          where: { id: userId },
          data: { role: 'ADMIN' },
        }),
      ]);

      return {
        resultCode: '00',
        resultMessage: 'Transfer approved th√†nh c√¥ng',
        data: {
          transfer: updatedTransfer,
          user: updatedUser,
        },
      };
    } catch (error) {
      console.error('üî• Error approving transfer:', error);
      throw error;
    }
  }

  async rejectTransfer(userId: number) {
    try {
      const transfer = await this.prisma.transferAdmin.findUnique({
        where: { userId },
      });

      if (!transfer) {
        return {
          resultCode: '01',
          resultMessage: `Kh√¥ng t√¨m th·∫•y Transfer v·ªõi userId = ${userId}`,
        };
      }

      return await this.prisma.transferAdmin.update({
        where: { userId },
        data: { status: 'REJECTED' },
      });
    } catch (error) {
      console.error('üî• Error rejecting transfer:', error);
      throw error;
    }
  }

  async findAllUserRequests() {
    try {
      const transt = await this.prisma.transferAdmin.findMany({
        include: {
          user: {
            select: {
              id: true,
              transferAdmin: true,
              role: true,
              email: true,
              name: true,
            },
          },
        },
      });
      return {
        resultCode: '00',
        resultMessage: 'Transfer data',
        list: transt,
      };
    } catch (error) {
      console.error('Error finding all user requests:', error);
      throw error;
    }
  }

  async createUserByAdmin(
    dto: CreateUserDto,
  ): Promise<BaseResponseDto<UserResponseDto | null>> {
    try {
      const existing = await this.prisma.user.findUnique({
        where: { email: dto.email },
      });

      if (existing) {
        return {
          resultCode: '01',
          resultMessage: 'Email ƒë√£ t·ªìn t·∫°i',
        };
      }

      const defaultPassword = dto.password ?? generatePassword(true);
      const hashedPassword = await bcrypt.hash(defaultPassword, 10);

      const user = await this.prisma.user.create({
        data: {
          email: dto.email,
          password: hashedPassword,
          tempPassword: hashedPassword,
          name: dto.name ?? '',
          pictureUrl: '',
          role: dto.role as Role,
          authType: 'ID,PW',
          userAlias: '',
          createdAt: toEpochDecimal(),
          updatedAt: toEpochDecimal(),
        },
      });

      try {
        await this.mailService.sendMail(
          dto.email,
          'T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c t·∫°o',
          `Xin ch√†o ${dto.name ?? 'b·∫°n'},\n\nT√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng.\nM·∫≠t kh·∫©u m·∫∑c ƒë·ªãnh: ${defaultPassword}`,
          `<p>Xin ch√†o <b>${dto.name ?? 'b·∫°n'}</b>,</p>
       <p>T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng.</p>
       <p><b>M·∫≠t kh·∫©u m·∫∑c ƒë·ªãnh:</b> ${defaultPassword}</p>
       <p>Vui l√≤ng ƒëƒÉng nh·∫≠p v√† ƒë·ªïi m·∫≠t kh·∫©u ngay.</p>`,
        );
      } catch (err) {
        console.error('G·ª≠i email th·∫•t b·∫°i:', err.message);
      }

      return {
        resultCode: '00',
        resultMessage: 'T·∫°o ng∆∞·ªùi d√πng th√†nh c√¥ng!',
        data: formatUserResponse(user),
      };
    } catch (error) {
      return {
        resultCode: '99',
        resultMessage: 'T·∫°o ng∆∞·ªùi d√πng khong th√†nh c√¥ng!',
      };
    }
  }

  // findOne(id: number) {
  //   return this.prisma.user.findUnique({ where: { id } });
  // }

  async requestUnlock(userId: number, reason: string) {
    const existing = await this.prisma.unlockRequest.findFirst({
      where: {
        userId,
        status: 'PENDING',
      },
    });

    if (existing) {
      return {
        resultCode: '99',
        resultMessage: 'B·∫°n ƒë√£ g·ª≠i y√™u c·∫ßu m·ªü kh√≥a, vui l√≤ng ch·ªù x·ª≠ l√Ω!',
      };
    }

    const user = await this.prisma.user.findUnique({ where: { id: userId } });

    if (!user)
      return {
        resultCode: '99',
        resultMessage: 'User kh√¥ng t·ªìn t·∫°i!',
      };

    if (user.accountLockYn !== 'Y') {
      return {
        resultCode: '99',
        resultMessage: 'T√†i kho·∫£n ch∆∞a b·ªã kh√≥a, kh√¥ng c·∫ßn m·ªü kh√≥a!',
      };
    }
    if (user.isEmailVerified !== 'Y') {
      return {
        resultCode: '99',
        resultMessage: 'Email ch∆∞a ƒë∆∞·ª£c x√°c th·ª±c, kh√¥ng th·ªÉ m·ªü kh√≥a!',
      };
    }

    return this.prisma.unlockRequest.create({
      data: {
        userId,
        reason,
        createdAt: nowDecimal(),
      },
    });
  }

  async getUserIdByEmail(email: string) {
    if (!email) {
      return {
        resultCode: '99',
        resultMessage: 'Vui l√≤ng cung c·∫•p email',
      };
    }
    const user = await this.prisma.user.findUnique({
      where: { email },
      select: { id: true },
    });

    if (!user) {
      return {
        resultCode: '99',
        resultMessage: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi email n√†y',
      };
    }

    return {
      resultCode: '00',
      resultMessage: 'Get Id ng∆∞·ªùi d√πng th√†nh c√¥ng!',
      data: { userId: user.id },
    };
  }

  async approveUnlockRequest(requestId: number) {
    const req = await this.prisma.unlockRequest.findUnique({
      where: { id: requestId },
      include: { user: true },
    });

    if (!req) {
      return {
        resultCode: '01',
        resultMessage: 'Y√™u c·∫ßu kh√¥ng t·ªìn t·∫°i!',
      };
    }

    if (req.status !== 'PENDING') {
      return {
        resultCode: '01',
        resultMessage: 'Y√™u c·∫ßu ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω!',
      };
    }

    await this.prisma.user.update({
      where: { id: req.userId },
      data: {
        accountLockYn: 'N',
        loginFailCnt: 0,
      },
    });

    await this.prisma.unlockRequest.update({
      where: { id: requestId },
      data: {
        status: 'APPROVED',
        approvedAt: nowDecimal(),
      },
    });

    return {
      resultCode: '00',
      resultMessage: 'Y√™u c·∫ßu ƒë√£ ƒë∆∞·ª£c duy·ªát v√† m·ªü kh√≥a.',
    };
  }

  async approveAllUnlockRequests() {
    const requests = await this.prisma.unlockRequest.findMany({
      where: { status: 'PENDING' },
      include: { user: true },
    });

    if (requests.length === 0) {
      return {
        resultCode: '99',
        resultMessage: 'Kh√¥ng c√≥ y√™u c·∫ßu n√†o c·∫ßn x·ª≠ l√Ω!',
      };
    }

    return this.prisma.$transaction(async (tx) => {
      for (const req of requests) {
        await tx.user.update({
          where: { id: req.userId },
          data: {
            accountLockYn: 'N',
            loginFailCnt: 0,
          },
        });

        await tx.unlockRequest.update({
          where: { id: req.id },
          data: {
            status: 'APPROVED',
            approvedAt: nowDecimal(),
          },
        });
      }

      return {
        resultCode: '00',
        resultMessage: `${requests.length} y√™u c·∫ßu ƒë√£ ƒë∆∞·ª£c duy·ªát v√† m·ªü kh√≥a.`,
      };
    });
  }

  async rejectUnlockRequest(requestId: number) {
    return this.prisma.unlockRequest.update({
      where: { id: requestId },
      data: {
        status: 'REJECTED',
        approvedAt: nowDecimal(),
      },
    });
  }

  async updateUserInfo(id: number, updateUserDto: UpdateUserInfoDto) {
    const user = await this.prisma.user.findUnique({
      where: { id },
    });

    if (!user) {
      return {
        resultCode: '99',
        resultMessage: `User with ID ${id} not found`,
      };
    }

    const isRoleChangingToAdmin =
      updateUserDto.role === Role.ADMIN && user.role !== Role.ADMIN;
    // const uploadResponse = await cloudinary.uploader.upload(updateUserDto.pictureUrl as string);
    let pictureUrl = user.pictureUrl;
    if (updateUserDto.pictureUrl) {
      const uploadResponse = await cloudinary.uploader.upload(
        updateUserDto.pictureUrl as string,
      );
      pictureUrl = uploadResponse.secure_url;
    }
    const updatedUser = await this.prisma.user.update({
      where: { id },
      data: {
        name: updateUserDto.name,
        pictureUrl,
        role: updateUserDto.role,
        userAlias: updateUserDto.userAlias,
        passport: updateUserDto.passport,
        phone: updateUserDto.phone,
        updatedAt: toEpochDecimal(),
      },
      select: { id: true },
    });

    if (isRoleChangingToAdmin) {
      const existingAdmin = await this.prisma.user.findFirst({
        where: { role: Role.ADMIN, NOT: { id: updatedUser.id } },
        select: { id: true },
      });

      await this.prisma.transferAdmin.create({
        data: {
          userId: updatedUser.id,
          fromUserId: updatedUser.id,
          toUserId: existingAdmin ? existingAdmin.id : updatedUser.id,
          status: 'PENDING',
          requestedAt: toEpochDecimal(),
          approvedAt: null,
        },
      });
    }

    return {
      resultCode: '00',
      resultMessage: 'C·∫≠p nh·∫≠t ng∆∞·ªùi d√πng th√†nh c√¥ng!',
      data: updatedUser,
    };
  }

  async updateUserFromAdmin(id: number, updateUserDto: UpdateUserFromAdminDto) {
    const user = await this.prisma.user.findUnique({
      where: { id },
    });

    if (!user) {
      return {
        resultCode: '99',
        resultMessage: `User with ID ${id} not found`,
      };
    }

    const updatedUser = await this.prisma.user.update({
      where: { id },
      data: {
        status: updateUserDto.status,
        department: updateUserDto.department as Department,
        position: updateUserDto.position as Position,
        baseSalary: updateUserDto.baseSalary,
        hireDate: updateUserDto.hireDate,
      },
      select: { id: true },
    });

    return {
      resultCode: '00',
      resultMessage: 'C·∫≠p nh·∫≠t ng∆∞·ªùi d√πng th√†nh c√¥ng!',
      data: updatedUser,
    };
  }

  async deleteAllUsers() {
    try {
      const result = await this.prisma.user.deleteMany({});
      return {
        resultCode: '00',
        resultMessage: `Xo√° to√†n b·ªô ng∆∞·ªùi d√πng th√†nh c√¥ng! (ƒê√£ xo√° ${result.count} user)`,
      };
    } catch (error) {
      console.error('Error deleting users:', error);

      return {
        resultCode: '99',
        resultMessage: error.message,
      };
    }
  }

  async setAccountLockChange(
    id: number,
  ): Promise<BaseResponseDto<{ accountLockYn: string }>> {
    const current = await this.prisma.user.findUnique({
      where: { id },
      select: { accountLockYn: true },
    });
    if (!current) {
      return { resultCode: '01', resultMessage: 'User kh√¥ng t·ªìn t·∫°i!' };
    }

    const newValue = current.accountLockYn === 'N' ? 'Y' : 'N';
    const updatedUser = await this.prisma.user.update({
      where: { id },
      data: { accountLockYn: newValue },
      select: { accountLockYn: true },
    });

    return {
      resultCode: '00',
      resultMessage: `ƒê√£ ƒë·ªïi tr·∫°ng th√°i accountLockYn t·ª´ ${current.accountLockYn} ‚Üí ${updatedUser.accountLockYn} th√†nh c√¥ng!`,
      data: updatedUser,
    };
  }

  async deleteUser(id: number) {
    try {
      const current = await this.prisma.user.findUnique({
        where: { id },
      });

      if (!current) {
        return { resultCode: '01', resultMessage: 'User kh√¥ng t·ªìn t·∫°i!' };
      }

      await this.prisma.user.delete({ where: { id } });

      return {
        resultCode: '00',
        resultMessage: `ƒê√£ delete success!`,
      };
    } catch (error) {
      console.error('Error:', error);
      throw error;
    }
  }

  async checkIn(employeeId: number) {
    return this.prisma.attendance.create({
      data: {
        employeeId,
        date: nowDecimal(),
        checkIn: nowDecimal(),
        checkOut: new Prisma.Decimal(0),
        status: 'PRESENT',
        createdAt: nowDecimal(),
      },
    });
  }

  async checkOut(attendanceId: number) {
    const checkOutTime = nowDecimal();
    const record = await this.prisma.attendance.update({
      where: { id: attendanceId },
      data: { checkOut: checkOutTime },
    });
    return record;
  }

  async createLeaveRequest(createDto: CreateLeaveRequestDto) {
    const employee = await this.prisma.user.findUnique({
      where: { id: createDto.employeeId },
    });

    if (!employee) {
      return {
        resultCode: '01',
        resultMessage: `Employee not found!`,
      };
    }

    // T·∫°o ƒë∆°n ngh·ªâ ph√©p
    const leaveRequest = await this.prisma.leaveRequest.create({
      data: {
        ...createDto, // copy c√°c field t·ª´ DTO
        appliedAt: nowDecimal(),
      },
    });

    return {
      resultCode: '00',
      resultMessage: 'Leave request created successfully',
      data: leaveRequest,
    };
  }

  async getAllLeaveRequests() {
    try {
      const leaveRequests = await this.prisma.leaveRequest.findMany({
        select: {
          id: true,
          leaveType: true,
          reason: true,
          startDate: true,
          endDate: true,
          days: true,
          status: true,
          employeeId: true,
          appliedAt: true,
          employee: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
        orderBy: {
          appliedAt: 'desc',
        },
      });

      return {
        resultCode: '00',
        resultMessage: 'Success',
        list: leaveRequests,
      };
    } catch (error) {
      return {
        resultCode: '99',
        resultMessage: 'Error fetching leave requests',
        error: error.message,
      };
    }
  }

  async deleteAllLeaveRequests() {
    try {
      // X√≥a t·∫•t c·∫£ leave requests
      const deleteResult = await this.prisma.leaveRequest.deleteMany({});

      return {
        resultCode: '00',
        resultMessage: `ƒê√£ x√≥a ${deleteResult.count} leave requests th√†nh c√¥ng`,
      };
    } catch (error) {
      return {
        resultCode: '99',
        resultMessage: error,
      };
    }
  }

  async checkEmployeeLeaveRequest(employeeId: number) {
    try {
      const currentTimestamp = new Date().getTime();
      const existingRequest = await this.prisma.leaveRequest.findFirst({
        where: {
          employeeId: employeeId,
          OR: [
            { status: 'PENDING' },
            {
              status: 'APPROVED',
              startDate: { gte: new Prisma.Decimal(currentTimestamp) },
            },
          ],
        },
        select: {
          id: true,
          leaveType: true,
          status: true,
          appliedAt: true,
          startDate: true,
          endDate: true,
        },
        orderBy: {
          appliedAt: 'desc',
        },
      });

      if (existingRequest) {
        return {
          resultCode: '00',
          resultMessage: 'ƒê√£ t·∫°o leave request',
          request: {
            ...existingRequest,
            appliedAt: existingRequest.appliedAt.toNumber(),
            startDate: existingRequest.startDate.toNumber(),
            endDate: existingRequest.endDate?.toNumber(),
          },
        };
      } else {
        return {
          resultCode: '09',
          resultMessage: 'Ch∆∞a t·∫°o leave request',
        };
      }
    } catch (error) {
      return {
        resultCode: '99',
        resultMessage: 'L·ªói khi ki·ªÉm tra leave request',
        error: error.message,
      };
    }
  }

  async approveLeaveRequest(
    requestId: number,
    approverId: number,
    note?: string,
  ) {
    if (!requestId || !approverId) {
      return {
        resultCode: '03',
        resultMessage: 'Request ID and Approver ID are required',
      };
    }

    const request = await this.prisma.leaveRequest.findUnique({
      where: { id: requestId },
    });

    if (!request) {
      return {
        resultCode: '01',
        resultMessage: 'Leave request not found!',
      };
    }

    if (request.status !== 'PENDING') {
      return {
        resultCode: '02',
        resultMessage: `Cannot approve request that is already ${request.status.toLowerCase()}`,
        currentStatus: request.status,
      };
    }

    // 4. Ki·ªÉm tra approver kh√¥ng ph·∫£i l√† ch√≠nh employee
    if (request.employeeId === approverId) {
      return {
        resultCode: '04',
        resultMessage: 'Approver cannot be the same as the requester',
      };
    }

    await this.prisma.leaveRequest.update({
      where: { id: requestId },
      data: {
        status: 'APPROVED',
        approverId,
        approverNote: note,
        decidedAt: nowDecimal(),
      },
    });

    return {
      resultCode: '00',
      resultMessage: 'Leave request approved',
    };
  }

  async rejectLeaveRequest(
    requestId: number,
    approverId: number,
    note?: string,
  ) {
    const request = await this.prisma.leaveRequest.findUnique({
      where: { id: requestId },
    });

    if (!request) {
      return {
        resultCode: '01',
        resultMessage: 'Leave request not found!',
      };
    }

    await this.prisma.leaveRequest.update({
      where: { id: requestId },
      data: {
        status: 'REJECTED',
        approverId,
        approverNote: note,
        decidedAt: nowDecimal(),
      },
    });

    return {
      resultCode: '00',
      resultMessage: 'Leave request rejected',
    };
  }

  //   async searchUsers(searchDto: SearchUserDto): Promise<PaginatedUserResponse> {
  //     const {
  //       name,
  //       email,
  //       employeeNo,
  //       role,
  //       status,
  //       department,
  //       position,
  //       page = 1,
  //       limit = 10,
  //       sortBy,
  //       sortOrder = 'asc',
  //     } = searchDto;

  //     const skip = (page - 1) * limit;

  //     const where: any = {
  //       ...(name && { name: { contains: name, mode: 'insensitive' } }),
  //       ...(email && { email: { contains: email, mode: 'insensitive' } }),
  //       ...(employeeNo && {
  //         employeeNo: { contains: employeeNo, mode: 'insensitive' },
  //       }),
  //       ...(role && { role }),
  //       ...(status && { status }),
  //       ...(department && { department }),
  //       ...(position && { position }),
  //     };

  //     const orderBy = sortBy ? { [sortBy]: sortOrder } : undefined;

  //     const [users, total] = await Promise.all([
  //       this.prisma.user.findMany({
  //         where,
  //         skip,
  //         take: limit,
  //         orderBy,
  //         // include: {
  //         //   attendance: { select: { employeeId: true } },
  //         // },
  //       }),
  //       this.prisma.user.count({ where }),
  //     ]);

  //     const userDtos: UserResponseDto[] = users.map((user) => ({
  //       id: user.id,
  //       employeeNo: user.employeeNo,
  //       email: user.email,
  //       name: user.name,
  //       role: user.role as Role,
  //       pictureUrl: user.pictureUrl,
  //       rank: user.rank,
  //       department: user.department as Department,
  //       position: user.position as Position,
  //       status: user.status as EmployeeStatus,
  //       lastLoginDate: user.lastLoginDate ? user.lastLoginDate.toNumber() : null, // Decimal ‚Üí number
  //       mfaEnabledYn: user.mfaEnabledYn,
  //       phone: user.phone,
  //       createdAt: user.createdAt.toNumber(),
  //       updatedAt: user.updatedAt.toNumber(),

  //       userAlias: user.userAlias,
  //       authType: user.authType,
  //       loginFailCnt: user.loginFailCnt ?? null,
  //       accountLockYn: user.accountLockYn,
  //     isEmailVerified: user.isEmailVerified ? 'Y' : 'N',
  //     }));

  //     return {
  //       users: userDtos,
  //       total,
  //       page,
  //       limit,
  //       totalPages: Math.ceil(total / limit),
  //     };
  //   }
  //   async getMessages (req: any, res: any) {
  //   try {
  //     const { senderId, receiverId } = req.params;

  //     const messages = await this.prisma.message.findMany({
  //       where: {
  //         OR: [
  //           { senderId: parseInt(senderId), receiverId: parseInt(receiverId) },
  //           { senderId: parseInt(receiverId), receiverId: parseInt(senderId) }
  //         ]
  //       },
  //       include: {
  //         sender: {
  //           select: {
  //             id: true,
  //             name: true,
  //             email: true,
  //             pictureUrl: true
  //           }
  //         },
  //         receiver: {
  //           select: {
  //             id: true,
  //             name: true,
  //             email: true,
  //                         pictureUrl: true
  //           }
  //         }
  //       },
  //       orderBy: {
  //         createdAt: 'asc'
  //       }
  //     });

  //     res.json(messages);
  //   } catch (error) {
  //     console.error('Error fetching messages:', error);
  //     res.status(500).json({ error: 'Internal server error' });
  //   }
  // };

  // // G·ª≠i tin nh·∫Øn m·ªõi
  //  async sendMessage (io: Server, data: any) {
  //   try {
  //     const { content, senderId, receiverId } = data;

  //     // T·∫°o tin nh·∫Øn m·ªõi trong database
  //     const newMessage = await prisma.message.create({
  //       data: {
  //         content,
  //         senderId: parseInt(senderId),
  //         receiverId: parseInt(receiverId),
  //         createdAt: new Date().getTime().toString() // Chuy·ªÉn th√†nh Decimal
  //       },
  //       include: {
  //         sender: {
  //           select: {
  //             id: true,
  //             name: true,
  //             avatar: true
  //           }
  //         },
  //         receiver: {
  //           select: {
  //             id: true,
  //             name: true,
  //             avatar: true
  //           }
  //         }
  //       }
  //     });

  //     // Ph√°t tin nh·∫Øn m·ªõi ƒë·∫øn ng∆∞·ªùi nh·∫≠n v√† ng∆∞·ªùi g·ª≠i
  //     io.to(`user_${receiverId}`).emit('new_message', newMessage);
  //     io.to(`user_${senderId}`).emit('new_message', newMessage);

  //     return newMessage;
  //   } catch (error) {
  //     console.error('Error sending message:', error);
  //     throw new Error('Failed to send message');
  //   }
  // };
}
